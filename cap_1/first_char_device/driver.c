#include <linux/fs.h>
#include <linux/atomic.h>
#include <linux/version.h>
#include <linux/module.h>
#include <linux/printk.h>
#include <linux/cdev.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/device.h>

#include <asm/errno.h>

#define DEVICE_NAME "fii"

static int major = -1;
static struct class *cls = NULL;
static atomic_t opened_times = ATOMIC_INIT(0);
static atomic_t closed_times = ATOMIC_INIT(0);

#define MESSAGE "Hello from the FII char device!\n"
#define MESSAGE_LEN 32

int device_open(struct inode* node, struct file* fp);
ssize_t device_read(struct file* fp, char __user* buffer, size_t length, loff_t *offset);
int device_release(struct inode* node, struct file* fp);

static struct file_operations fops = {
    .open = device_open,
    .read = device_read,
    .release = device_release,
};

int init_module(void) {
    // A device needs a major number of registering
    major = register_chrdev(0, DEVICE_NAME, &fops);
    if (major < 0) {
        printk(KERN_ERR "Could not register the /dev/fii device! Received major: %d\n", major);
        return major;
    }

    // The devices needs a class to not create the device using mknod
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,4,0)
    cls = class_create(DEVICE_NAME);
#else
    cls = class_create(THIS_MODULE, DEVICE_NAME);
#endif

    if (cls < 0) {
        printk(KERN_ERR "Could not register the /dev/fii device! The class received was invalid\n");
        return (uint64_t)cls;
    }

    // The actual creation of the device
    device_create(cls, NULL, MKDEV(major, 0), NULL, DEVICE_NAME);

    return 0;
}

void cleanup_module(void) {
   device_destroy(cls, MKDEV(major, 0)); 
   class_destroy(cls);

   unregister_chrdev(major, DEVICE_NAME);
}

int device_open(struct inode* node, struct file* fp) {
    atomic_inc(&opened_times);
    printk(KERN_INFO "The device /dev/" DEVICE_NAME " was opened for %d times", opened_times.counter);
    return 0;
}

ssize_t device_read(struct file* fp, char __user* buffer, size_t length, loff_t *offset) {
    // Get the minimum length from the one received and the actual message
    size_t min_length = MESSAGE_LEN > length ? length : MESSAGE_LEN;
    // Write the message to the buffer from the user
    size_t bytes_not_wrote = copy_to_user(buffer, MESSAGE, min_length);
    printk(KERN_INFO "Wrote to the user buffer: %lu bytes\n", min_length);
    return bytes_not_wrote ? -EFAULT : min_length;
}

int device_release(struct inode* node, struct file* fp) {
    atomic_inc(&closed_times);
    printk(KERN_INFO "The device /dev/" DEVICE_NAME " was opened for %d times", closed_times.counter);
    return 0;
}

MODULE_LICENSE("GPL");
