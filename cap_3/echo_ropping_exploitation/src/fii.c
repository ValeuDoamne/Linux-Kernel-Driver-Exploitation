#include <linux/printk.h>
#include <linux/module.h>
#include <linux/version.h>
#include <linux/proc_fs.h>
#include <linux/string.h>

#define DEVICE_NAME "fii"

#define BUFFER_SIZE 256
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
#define HAVE_PROC_OPS
#endif

static struct proc_dir_entry *proc_file;

char GLOBAL_DATA[BUFFER_SIZE];
static ssize_t read_op(struct file* fp, char __user *buffer, size_t length, loff_t *offset) {
    char local_buffer[BUFFER_SIZE] = { 0 };
    memcpy(local_buffer, GLOBAL_DATA, BUFFER_SIZE);
    if(copy_to_user_nofault(buffer, local_buffer, length)) {
        printk(KERN_ERR "Could not copy to the user buffer!\n");
        return 0;
    }
    return length;
}

static ssize_t write_op(struct file* fp, const char __user *buffer, size_t length, loff_t *offset) {
    char local_buffer[BUFFER_SIZE] = { 0 };
    if (copy_from_user_nofault(local_buffer, buffer, length)) {
        printk(KERN_ERR "Could not write into kernel memory the buffer provided!\n");
        return 0;
    }
    memcpy(GLOBAL_DATA, local_buffer, BUFFER_SIZE);
    return length;
}


#ifdef HAVE_PROC_OPS 
static const struct proc_ops proc_fops = { 
    .proc_read = read_op, 
    .proc_write = write_op,
}; 
#else 
static const struct file_operations proc_fops = { 
    .read = read_op, 
    .write = write_op,
}; 
#endif

int init_module(void) {
    // Set the permission to read/write for everyone 
    proc_file = proc_create(DEVICE_NAME, 0666, NULL, &proc_fops);
    if (proc_file == NULL) {
        proc_remove(proc_file);
        printk(KERN_ERR "Error could not initiate: /proc/" DEVICE_NAME "\n");
        return -ENOMEM;
    }
    return 0;
}

void cleanup_module(void) {
    proc_remove(proc_file);
    kfree(GLOBAL_DATA);
    printk(KERN_INFO "Successfully removed the device /proc/" DEVICE_NAME "!\n");
}

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Cosmin Alexa");
